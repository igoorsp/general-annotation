
Essa documentação incluirá:

* Tabela de decisão clara com critérios como volume, tempo de execução, tipo de integração, timeout, etc.
* Exemplos de uso para cada caso
* Considerações de custo e escalabilidade
* Sugestão de padrão arquitetural para cada decisão

Já inicio essa tarefa e aviso quando estiver pronta para revisão.


# Guia de Migração de Service Tasks do Camunda para AWS Step Functions (Lambda vs EKS Callback)

## Introdução

A migração de processos BPMN do Camunda para **AWS Step Functions** permite aproveitar a orquestração serverless e eliminar a dependência de um motor BPMN tradicional. Um dos principais desafios nessa migração é determinar como implementar as **Service Tasks** do Camunda em Step Functions. Duas abordagens comuns são: usar **funções AWS Lambda** para executar tarefas diretamente, ou usar o padrão de **callback com Amazon SQS e Amazon EKS** (Kubernetes) para tarefas assíncronas de longa duração ou com requisitos especiais.

Este guia, em formato de "receita", fornece uma orientação passo-a-passo e critérios claros para ajudar equipes de arquitetura e desenvolvimento a decidir entre essas opções. Apresentaremos uma **tabela de decisão** com critérios técnicos e operacionais, explicaremos em quais cenários cada abordagem é mais adequada, e daremos exemplos práticos. Também discutiremos considerações de **custo, latência e escalabilidade**, e sugeriremos arquiteturas de referência para cada escolha (Step Functions com Lambda vs Step Functions com SQS + EKS).

O objetivo é servir como um **guia técnico** bem organizado e de fácil consulta, para equipes migrando fluxos de trabalho Camunda BPMN para AWS Step Functions.

## Tabela de Decisão – AWS Lambda vs EKS (Callback com SQS)

A tabela a seguir resume critérios-chave para decidir entre implementar uma Service Task como uma função Lambda acionada pelo Step Functions ou usar o padrão de callback com uma fila SQS e um worker em EKS. Cada critério inclui indicações de qual abordagem tende a ser mais apropriada dado determinado cenário:

| **Critério**                    | **Step Functions + AWS Lambda**                                                                                                                                                                                                                                                                                                                                                                                                                            | **Step Functions + EKS com SQS (Callback)**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| ------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Volume diário de execuções**  | *Baixo a moderado:* Volumes esporádicos ou moderados favorecem Lambda, pois você paga somente por execução e não há infraestrutura ociosa. Lambdas suportam escalabilidade automática para milhares de requisições simultâneas, ideal para cargas variáveis.                                                                                                                                                                                               | *Alto e constante:* Volumes elevados e constantes podem justificar EKS. Containers rodando continuamente podem sair mais baratos em cargas sustentadas, já que em EKS você reserva recursos fixos (custos previsíveis). Além disso, filas SQS ajudam a nivelar picos, distribuindo tarefas entre múltiplos pods.                                                                                                                                                                                                                                                                                                                                             |
| **Duração média da task**       | *Curta (até alguns minutos):* Lambdas são ideais para tarefas rápidas (segundos ou poucos minutos). Como têm limite máximo de 15 minutos por invocação, encaixam bem em tasks curtas. A execução é síncrona dentro do fluxo Step Functions, que espera a resposta do Lambda antes de prosseguir.                                                                                                                                                           | *Longa (vários minutos ou horas):* Para tasks que podem exceder 15 minutos ou demoram muito, use o padrão de callback. Step Functions (Standard) pode aguardar até 1 ano por uma resposta assíncrona. A tarefa é enviada via SQS e processada no seu tempo em EKS, liberando o Step Functions para esperar sem bloquear um Lambda.                                                                                                                                                                                                                                                                                                                           |
| **Timeout necessário**          | *Até 15 minutos:* Lambdas possuem timeout máximo de 900 segundos (15 min). Se a lógica da Service Task pode ser concluída dentro desse tempo, Lambda é viável. É possível configurar o timeout da função Lambda adequadamente (p.ex. encerrar em 30s se normalmente leva 5s, etc).                                                                                                                                                                         | *Superior a 15 min:* Se a tarefa pode exceder o limite do Lambda, deve ser feita fora dele. Com EKS + callback, o Step Functions pode iniciar o trabalho e **esperar** o tempo necessário (configurando um timeout maior no estado ou usando heartbeat). Exemplo: processamento batch de 2 horas, ou espera por resposta de processo externo humano ou de máquina.                                                                                                                                                                                                                                                                                           |
| **Reutilização de código**      | *Função específica reutilizável:* Se a lógica da Service Task pode ser encapsulada numa função bem definida, Lambda permite fácil reutilização por múltiplos workflows ou disparos diretos. Lambdas são boas para implementar **micro-serviços stateless** sob demanda.                                                                                                                                                                                    | *Serviço persistente ou dependência pesada:* Se a tarefa já existe como um serviço/container (por ex., um microserviço em Kubernetes) ou requer bibliotecas/hardware especiais (por ex. dependências > 250 MB, uso de GPU, etc.), faz sentido mantê-la em EKS. O Step Functions pode integrar-se via SQS sem refatorar profundamente o código existente do serviço.                                                                                                                                                                                                                                                                                          |
| **Integração e conectividade**  | *Integrações AWS e simples (REST/APIs):* Lambdas integram-se nativamente com outros serviços AWS (SDK pronto, permissões via IAM) e podem acessar VPCs privadas se necessário. Ideal para chamar APIs REST, serviços AWS (S3, DynamoDB, etc.) ou banco de dados via internet. Para acessar recursos em VPC, Lambdas suportam ENIs em sub-redes privadas (com algum overhead de cold start).                                                                | *Recursos em VPC/On-Prem ou dependência de estado:* Se a Service Task precisa acessar diretamente sistemas em uma VPC privada, rede legada ou manter conexões persistentes (ex: conexão constante a um banco de dados), um **worker em EKS** pode ser mais adequado. Em EKS, os pods residem na VPC e podem manter pools de conexão ou estado em memória. O padrão de callback via SQS desacopla a chamada, permitindo que o processamento ocorra em ambiente controlado (ex: dentro de um cluster com acesso a sistemas on-premises).                                                                                                                       |
| **Padrão de carga**             | *Eventual e imprevisível:* Em cargas esporádicas ou picos imprevisíveis, Lambda brilha – escala automaticamente sem precisar pre-provisionar nada, e não incorre custo quando ociosa. Cold starts podem ocorrer, mas para invocações ocasionais isso costuma ser aceitável.                                                                                                                                                                                | *Contínua ou agendada:* Se as tasks ocorrem regularmente em alto volume (ex: processamento batch noturno fixo) ou exigem execução contínua (ex: consumidores de fila sempre ligados), EKS pode ser preferível. Com containers, você pode manter instâncias **sempre prontas** (evitando cold start) e ajustar a escala gradualmente. Para cargas constantes, um cluster pode ser otimizado para rodar perto de 60-70% de uso de CPU por pod, aumentando eficiência de custo.                                                                                                                                                                                 |
| **Custos e modelo de cobrança** | *Pay-per-use:* Lambda cobra por invocação e tempo de execução (GB-segundos). É geralmente econômico para workloads intermitentes ou de baixo volume, pois não há custo fixo de infraestrutura ociosa. Entretanto, em altíssimo volume contínuo, o custo pode crescer linearmente com uso. *Nota:* Step Functions Standard também cobra por transição de estado, então muitos estados (cada chamada Lambda conta) impactam no custo.                        | *Infraestrutura alocada:* EKS envolve custos de manter nós EC2 ou Fargate provisionados, mesmo que o workload esteja ocioso. Pode ser vantajoso para workloads estáveis e intensivos, onde manter containers ocupados sai mais barato do que pagar por milhões de invocações Lambda. Considere também o custo operacional de gerenciar o cluster. Além disso, há custo de mensagens SQS e do Step Functions (estado de espera) – geralmente baixos, mas existentes para longas esperas.                                                                                                                                                                      |
| **Latência e desempenho**       | *Baixa latência em tarefas curtas:* Lambdas escritos em linguagens eficientes podem ter latência de poucos dezenas de milissegundos em execução. Porém, considere o **cold start**: na primeira invocação (ou após período inativo), a função pode demorar algumas centenas de ms a segundos para iniciar (especialmente se em VPC ou runtime pesado). Para tarefas frequentes, pode-se mitigar com *Provisioned Concurrency* ou mantendo a função quente. | *Processamento pesado ou tempo real consistente:* Se a tarefa requer inicialização de grande ambiente (ex: carregamento de modelos ML gigantes) ou precisa de resposta em tempo muito controlado sem variação, talvez seja melhor usar um pod permanente em EKS. O pod pode ficar residente em memória, evitando latência de inicialização a cada execução. Em geral, um serviço em container ativo pode responder um pouco mais rápido que um Lambda frio em cenários de APIs de baixa latência. Todavia, a adição de SQS + Step Functions insere latência extra (fila + callback), então use esse padrão apenas se puder tolerar essa natureza assíncrona. |
| **Complexidade Operacional**    | *Menor overhead (Serverless):* Lambdas não exigem gerência de servidores ou containers – a implantação e scaling são gerenciados pelo AWS. Isso simplifica a operação e reduz a necessidade de um time DevOps/Kubernetes especializado. Testes podem ser feitos invocando diretamente a função com eventos simulados, e o CloudWatch Logs centraliza os logs.                                                                                              | *Maior controle, maior complexidade:* Usar EKS implica gerenciar um cluster Kubernetes (ou ao menos suas aplicações). É necessário configurar deployments ou jobs para consumir da SQS (por exemplo, um **poller** contínuo), fazer deploy de imagens de container, monitorar pods, etc. Requer mais esforço de setup e manutenção, mas em troca oferece **maior controle** sobre o ambiente de execução (versões de runtime customizadas, tuning fino de rede, uso de volumes, etc.). Aproveite EKS se sua equipe já possui expertise em Kubernetes e se os benefícios superam a simplicidade do Lambda.                                                    |

**Legenda:** Critérios técnicos (como limites de tempo, padrões de carga, etc.) e critérios operacionais (como modelo de custos e facilidade de manutenção) foram considerados. Use esta tabela como orientação geral – casos específicos podem exigir avaliação mais detalhada.

## Quando Usar AWS Lambda em Step Functions

Optar por AWS Lambda para implementar uma Service Task geralmente é recomendável nos seguintes cenários:

* **Tarefas curtas e sem estado:** Se a Service Task representa uma chamada rápida (geralmente segundos ou poucos minutos) a algum serviço, cálculo ou integração, uma função Lambda é ideal. Lambdas podem ser invocadas diretamente em um estado do Step Functions do tipo Task. O Step Functions aguardará a conclusão da função (invocação **síncrona**, retornando o resultado) antes de prosseguir para o próximo passo. Esse modelo síncrono é simples e eficaz para fluxos de trabalho onde cada passo depende do resultado imediato do anterior. Por exemplo, chamar uma API de verificação de crédito ou gravar um registro em banco de dados pode ser feito em poucos segundos – perfeito para Lambda.

* **Volumes variáveis ou imprevisíveis:** Lambdas escalam automaticamente conforme a demanda, até limites muito altos de concorrência (milhares de instâncias em paralelo, dependendo das quotas). Você não precisa prever capacidade – o AWS gerencia isso. Assim, se a carga de Service Tasks varia ao longo do dia ou é imprevisível, Lambdas fornecem robustez e custam apenas pelo tempo utilizado. Em contrapartida, manter pods de Kubernetes ociosos aguardando picos poderia desperdiçar recursos. Conforme mencionado, o modelo de custo do Lambda (pagamento por tempo de execução) tende a ser vantajoso em workloads intermitentes ou com picos.

* **Simplicidade e velocidade de desenvolvimento:** Criar uma função Lambda normalmente exige menos esforço operacional. Basta empacotar o código (ZIP ou imagem de container) e implantar. A integração com Step Functions é direta via *ARN* da função no estado. Para equipes pequenas ou com pouca experiência em Kubernetes, essa simplicidade ajuda. Além disso, Lambdas podem ser testadas isoladamente facilmente (por exemplo, usando eventos de teste no console ou ferramentas como SAM CLI). Se a prioridade é entregar rápido e reduzir complexidade, Lambdas são a primeira escolha.

* **Integração nativa com serviços AWS:** Muitas Service Tasks envolvem operações em serviços AWS (gravar no DynamoDB, colocar objeto no S3, enviar e-mail via SES, etc.). Embora Step Functions possua integrações diretas com vários serviços, usar um Lambda permite flexibilidade total de programação com o AWS SDK. Como Lambdas rodam com credenciais IAM, é fácil dar permissão para acessar recursos AWS necessários. Em contrapartida, um container em EKS precisaria usar um Role assumido via IRSA (IAM Roles for Service Accounts) ou outras configurações para ter credenciais AWS – é viável, mas um passo a mais.

* **Tempo de vida curto e sem necessidade de estado persistente:** Lambdas têm um tempo de vida efêmero – o container é descartado após algum tempo de inatividade. Isso é ótimo para tarefas isoladas que não precisam manter nada em memória entre invocações. Cada execução começa em um ambiente limpo (exceto pelo possível reuso de um container *quente*), garantindo isolamento. Se a lógica da Service Task não requer persistir contexto além do que o Step Functions já passa via input/output, Lambdas atendem perfeitamente.

Resumindo, use **Step Functions + Lambda** quando suas Service Tasks forem *rápidas, síncronas, escaláveis sob demanda e fáceis de implementar* sem precisar de infraestrutura dedicada. A maior parte das tasks comuns (integrações REST, processamento leve de dados, chamadas a serviços AWS) se encaixa nesse perfil. Lembre-se apenas das limitações: **tempo máximo de 15 minutos**, tamanho de pacote (descompactado até \~250 MB ou 10 GB se usar container image) e cuidado com cold starts caso desempenho de milissegundos seja crítico.

## Quando Usar EKS com SQS (Padrão de Callback)

Apesar das vantagens do Lambda, há situações em que implementar a Service Task usando um worker externo em um cluster EKS (ou outra plataforma de containers) é mais adequado. Nessa abordagem, o Step Functions **não executa diretamente a lógica**, mas sim **orquestra um trabalho assíncrono**. Geralmente se dá assim: o Step Functions envia uma mensagem para uma fila **Amazon SQS** contendo os dados da tarefa (e um *token* de callback), então um serviço ou pod no **Amazon EKS** consome essa mensagem, processa a lógica necessária e por fim chama a API do Step Functions para sinalizar a conclusão (usando o token). Esse é o **Callback Pattern** suportado nativamente pelo Step Functions. Quando escolher este modelo?

* **Tarefas longas ou assíncronas:** Como mencionado, qualquer tarefa que potencialmente dure mais que 15 minutos **não pode** rodar inteiramente dentro de um Lambda. Exemplos: geração de um relatório extenso, processamento de lote de milhões de registros, espera por um evento externo (p. ex., finalizar uma tarefa manual ou aguardar recurso ficar disponível). O Step Functions Standard consegue esperar por resultados externos por até **1 ano**, portanto suporta bem esses cenários. Ao enviar a tarefa para uma fila SQS e pausar o estado (wait for callback), liberamos o fluxo para aguardar sem ocupar recursos de computação. O worker no EKS faz o trabalho pesado no seu próprio ritmo e notifica quando terminar. Esse modelo também evita pagar por um Lambda travado esperando (o que seria cobrado mesmo ocioso). Em suma, use callback em *tarefas demoradas* ou *de duração indeterminada*.

* **Recursos computacionais ou de ambiente especiais:** Se a lógica da Service Task requer algo além do que o Lambda fornece, o EKS pode ser a solução. Por exemplo, uso de **bibliotecas nativas específicas**, dependências muito grandes, ou requisitos de **hardware especializado** (como GPUs, alto número de CPUs, grandes volumes de memória). Enquanto Lambdas hoje suportam até 10 GB de memória e 6 vCPUs, há workloads de ML/AI ou processamento científico que precisam de ainda mais ou de GPUs – ambientes que tipicamente rodam melhor em containers sobre EC2/EKS. Com EKS, você pode escolher instâncias EC2 otimizadas (p. ex., instâncias GPU) para seus pods. Além disso, se o código já existe como um container Docker usado on-premise ou em outra cloud, reaproveitá-lo no EKS pode dar velocidade à migração, em vez de refatorar para Lambda.

* **Manter estado em memória ou conexões persistentes:** Diferente do modelo stateless do Lambda, um **serviço rodando continuamente em um pod** pode manter contexto entre as requisições. Isso é útil, por exemplo, para **pool de conexões** a banco de dados (evitando overhead de conectar a cada execução) ou cache de dados em memória para aceleração. Em Lambdas, cada invocação pode reutilizar o contexto quente *dentro da mesma instância*, mas não há garantia de usar a mesma instância entre invocações (e escalando vai haver muitas instâncias). Num padrão com SQS + EKS, você pode optar por ter um número fixo de workers lendo da fila; esses workers podem gerenciar conexões de forma controlada. Por exemplo, se uma Service Task do Camunda consultava um banco relacional pesado, pode ser mais seguro ter 2 ou 3 pods consumindo uma fila processando requisições sequencialmente, do que 100 Lambdas disparando 100 conexões simultâneas e possivelmente sobrecarregando o DB. Assim, *tarefas que envolvem interação com sistemas legados, que exigem controle de throughput ou contexto compartilhado*, se beneficiam do uso de EKS.

* **Fluxos desacoplados e resilientes:** O uso de fila SQS introduz um **buffer** entre o orquestrador (Step Functions) e o executor (worker). Isso desacoplamento traz vantagens de robustez: a mensagem permanece na fila até ser processada, podendo ser retentada em caso de falha do worker, etc. Se o cluster EKS estiver momentaneamente sem pods disponíveis, as mensagens ficam na fila aguardando. Esse padrão aumenta a tolerância a falhas temporárias do consumidor ou lentidão. Em contrapartida, no modelo Lambda síncrono, se o Lambda falha ou expira, o Step Functions tem que lidar com o erro imediatamente (fazendo retry ou abortando). No callback pattern, você tem mais liberdade para tratar reprocessamentos no lado do worker (recolocando mensagem na fila, por exemplo, ou usando Dead Letter Queue para não perder tarefas). Para *processos críticos que demandam alta confiabilidade*, esse extra de robustez pode ser importante.

* **Preferência por stack Kubernetes/Containers:** Por fim, considere o contexto da equipe e arquitetura existente. Se sua empresa já opera um cluster Kubernetes (EKS) com várias aplicações, e a equipe possui experiência sólida com containers, pode ser natural aproveitar essa infraestrutura para certas Service Tasks. Por exemplo, talvez você já tenha um serviço interno que realiza uma determinada função (ex: cálculo de risco) rodando em EKS; em vez de portar essa lógica para Lambda, você pode simplesmente *acoplar* o workflow do Step Functions a ele via SQS. Isso preserva investimentos feitos e reduz a necessidade de manter duas implementações diferentes da mesma funcionalidade. Apenas lembre-se de que, ao optar por EKS, você aceita a complexidade operacional citada (monitorar pods, escalonar nós, etc.). Em geral, use **Step Functions + EKS (callback)** quando os *requisitos técnicos* da task (duração, ambiente, recursos) ou *restrições de integração* tornem o Lambda impraticável ou subótimo.

Em resumo, o **padrão de Callback com SQS + EKS** é indicado para *tarefas assíncronas de longa duração, ou aquelas que exigem um ambiente de execução customizado/persistente*. O Step Functions suporta diretamente esse modelo de enviar token e esperar callback. Embora haja um pequeno custo de complexidade adicional, ele traz a flexibilidade de executar praticamente qualquer workload dentro de um fluxo Step Functions.

## Exemplos Ilustrativos de Service Tasks Migradas

A seguir, apresentamos alguns cenários típicos de Service Tasks em processos Camunda e como seriam implementados em Step Functions, destacando a escolha entre Lambda e EKS:

* **Exemplo 1: Consulta de serviço externo rápida (Lambda)** – Considere uma tarefa no Camunda que chama uma API de terceiros (por exemplo, verificar o score de crédito de um cliente) e prossegue com o resultado. Essa ação normalmente leva 1 ou 2 segundos. Na migração para AWS, essa Service Task pode ser substituída por um estado do Step Functions que invoca uma função Lambda que realiza a chamada HTTP ao serviço externo e retorna o score. O Step Functions ficará em **wait** durante a execução do Lambda e retoma assim que obtém a resposta, usando-a para decidir próximos passos (ex: aprovação ou rejeição). **Por que Lambda?** É uma operação de curta duração e *síncrona* – o fluxo precisa do resultado imediatamente. Usar EKS + fila aqui seria desnecessariamente complexo e introduziria atrasos. A Lambda consegue tratar a requisição e retornar rapidamente dentro do mesmo estado.

* **Exemplo 2: Processamento batch demorado (EKS Callback)** – Imagine um processo Camunda que envolva gerar um relatório consolidado a partir de milhões de registros, algo que no ambiente atual é feito por um programa Java executando por 40 minutos. Em Step Functions, tentar colocar essa lógica em um Lambda esbarraria no limite de 15 minutos, além de possivelmente exigir memória/cpu consideráveis. A solução recomendada é utilizar o **callback pattern**: o Step Functions, ao chegar nessa etapa, poderia enviar uma mensagem para uma fila SQS contendo parâmetros necessários (por exemplo, referência aos dados a processar e um *task token* do Step Functions). No cluster EKS, um **pod worker** ouviria a fila, iniciaria o job pesado de geração de relatório (poderia até disparar um *Kubernetes Job* interno para paralelizar, dependendo do caso) e, ao terminar o processamento, chamaria a API do Step Functions (SendTaskSuccess) com o token para sinalizar conclusão com sucesso ou erro. O Step Functions, que ficou aguardando de forma passiva, então continua o fluxo (por exemplo, notificando que o relatório está pronto). **Por que EKS?** Trata-se de uma tarefa *muito longa e intensiva*, inadequada para Lambda. No EKS podemos alocar recursos sob medida (uma máquina grande ou várias em paralelo). Além disso, enquanto o processamento ocorre, o Step Functions não consome recurso computacional (só mantém o estado aguardando). Esse padrão garante que não haverá timeout prematuro no orquestrador e oferece mais controle sobre o trabalho em si (pod pode registrar progresso, checkpoints, etc., que seriam difíceis de gerenciar dentro de um Lambda).

* **Exemplo 3: Integração com sistema legado via VPN (EKS Callback)** – Suponha que um passo do fluxo de negócio precise interagir com um sistema interno on-premises, acessível apenas via VPN ou link dedicado, talvez usando um protocolo específico. No Camunda original, podia haver um serviço Java rodando em um servidor interno consumindo essa tarefa. Para migrar isso à nuvem, podemos aproveitar o EKS: execute um componente (pod) dentro do EKS que tenha acesso a essa VPN (usando AWS VPN/Direct Connect atachado à VPC do cluster) e que implemente o protocolo legado. O Step Functions envia uma mensagem a uma fila SQS com os dados da requisição, o worker no EKS consome e realiza a transação com o sistema on-prem, obtendo a resposta, e então faz o callback para Step Functions com o resultado. **Por que não Lambda?** Embora Lambdas pudessem viver dentro da VPC e teoricamente acessar a VPN, um Lambda iniciando uma conexão pesada ou usando bibliotecas legadas seria menos ideal. Provavelmente esse worker já existe como um serviço contínuo (ou seria mais estável rodando continuamente devido à natureza do protocolo). O EKS oferece um ambiente mais próximo de um servidor tradicional para esse tipo de tarefa, com a fila garantindo entrega confiável. Novamente, a natureza *assíncrona* dessa integração (pode demorar vários segundos ou minutos, dependendo do sistema remoto) se encaixa no padrão callback.

* **Exemplo 4: Cálculo intensivo com biblioteca nativa (EKS Callback)** – Uma empresa possui uma Service Task que calcula previsões estatísticas pesadas usando uma biblioteca nativa em C++ que leva 5 minutos para computar resultados. Migrar isso para Lambda exigiria empacotar a biblioteca para Lambda (possível, mas talvez complicada devido a dependências nativas e tamanho). Além disso, 5 minutos está dentro do limite, porém próximo – e variações poderiam passar disso. Aqui a organização opta por criar um container Docker com seu aplicativo C++ e rodá-lo no EKS. O Step Functions então utiliza um estado de callback similar: envia a requisição via SQS, um pod no EKS (escalável conforme demanda usando, por exemplo, KEDA para auto-escalar baseado no tamanho da fila) recebe e executa o cálculo, retornando quando pronto. **Motivo da escolha:** O container proporciona um ambiente consistente para a biblioteca nativa, e o EKS lida melhor com uso intenso de CPU/RAM em um único processo (pod) sem risco de ser pausado no meio. Além disso, se quiserem paralelizar o cálculo, poderiam rodar múltiplos pods consumindo tarefas distintas em paralelo, controlando a concorrência via SQS. Em Lambda, embora pudesse instanciar várias funções simultâneas, o overhead de cada função carregar a lib nativa de grande porte poderia ser maior.

Esses exemplos ilustram a aplicação prática dos critérios. Em suma: **tarefas curtas/simples -> Lambda**, **tarefas longas/complexas -> EKS com callback**. Sempre avalie cada caso considerando limites e requisitos específicos.

## Considerações sobre Custo, Latência e Escalabilidade

Migrar do Camunda para Step Functions envolve mudanças no modelo de custo e desempenho. Vamos detalhar comparativamente os dois cenários (Lambda vs EKS) nesses aspectos críticos:

* **Custo:** Em Camunda self-hosted, o custo estava atrelado a manter servidores ou ao licenciamento. No modelo Step Functions + Lambda, os custos passam a ser **operacionais por uso** – você paga pelas transições de estado do Step Functions e pelo tempo de execução das Lambdas (GB-segundos). Isso tende a ser econômico se o processo não estiver constantemente ativo em larga escala. Por outro lado, Step Functions + EKS introduz custos fixos de infraestrutura: as instâncias EC2 do cluster (ou custos do Fargate nos nós) estarão faturando 24/7 independentemente do uso, além do Step Functions e SQS (que custam centavos por milhão de mensagens/transições). Para cargas **irregulares ou de baixo uso**, Lambdas terão custo substancialmente menor, pois quando o workflow não roda, não se paga quase nada. Já para cargas **constantes e altas**, é preciso analisar. Lambdas em altíssimo volume podem atingir contas significativas, enquanto manter um conjunto de pods ocupados pode sair relativamente mais barato. Por exemplo, se um workflow consome 1000 vCPUs continuamente, provavelmente será mais barato rodar isso em instâncias EC2 reservadas do que em 1000 Lambdas concorrentes 24h. **Regra prática:** use Lambda quando em dúvida inicial – pague apenas pelo uso e evite upfront. Caso mensure posteriormente que há uso contínuo alto, pode-se migrar aquela task para um container. Também lembre que EKS traz custos indiretos: tempo de engenharia para manutenção do cluster, monitoring extra, etc., que devem ser considerados no *TCO* (Total Cost of Ownership).

* **Latência:** Em termos de latência de cada tarefa, a chamada direta via Lambda será geralmente mais rápida de ponta a ponta do que via SQS+EKS, simplesmente por evitar hops adicionais. Uma função Lambda pode ser invocada e responder em, digamos, 100 ms. Já o padrão com SQS envolve colocar na fila, o pod ler (dependendo do polling, pode ter alguns segundos de delay se usar long polling ou mais instantâneo com push mechanisms/KEDA), e então o callback. Isso adiciona latência pelo menos na ordem de segundos geralmente, tornando o padrão callback mais adequado a **processos assíncronos** onde alguns segundos/minutos de espera são aceitáveis. Além disso, **cold start** precisa ser considerado: Lambdas inativos sofrem cold start de algumas centenas de milissegundos (até \~1s para runtimes gerenciados, possivelmente mais se em VPC ou usando pacote grande). EKS pods, se você escala de zero, podem demorar dezenas de segundos para agendar e iniciar, mas se mantém ao menos 1 réplica ativa, as requisições encontram o worker já pronto (pod quente). No entanto, em casos de APIs síncronas de altíssima exigência de latência (baixa dezenas de ms), ambos podem precisar de tunings (Provisioned Concurrency para Lambda ou manter pods sobreprovisionados em EKS). Uma observação de benchmark: serviços HTTP simples em Fargate/EKS podem responder em \~20-30ms, enquanto Lambdas via API Gateway tendem a \~50ms devido à plataforma – diferença pequena, mas existente. Em Workflows Step Functions, isso raramente será um problema pois Step Functions não é típico para requisições interativas de baixa latência, mas sim para orquestração de *negócio* onde segundos são aceitáveis. Portanto, a latência só deve pesar na decisão se seu processo realmente exige resposta *imediata* em alguma etapa – se sim, prefira Lambdas síncronas ou até mova aquela parte para fora do Step Functions (talvez um serviço dedicado). No geral, para **latência baixa** e consistência, Lambda é mais previsível se conseguir mantê-la aquecida; EKS adiciona latência pela fila mas permite eliminar cold starts se dimensionado corretamente.

* **Escalabilidade:** Ambos os cenários são escaláveis, mas de maneiras diferentes. O Step Functions em si escala internamente (pode executar milhares de fluxos em paralelo, cada um criando Lambdas ou tokens SQS), então a diferença está em como a *tarefa* escala:

  * *Lambda:* Escala praticamente sem esforço – cada nova execução do estado Step Functions invoca uma função Lambda que roda isoladamente. O AWS Lambda automaticamente aloca mais instâncias conforme necessário, até o limite de concorrência configurado (padrão 1000 conc. por função, ajustável). Em geral, você obtém **escalabilidade instantânea vertical e horizontal** – se 500 fluxos chegarem ao mesmo tempo, 500 Lambdas podem rodar em paralelo (sujeito a limites). Isso é ótimo para throughput, mas cuidado: se esses Lambdas acessam recursos compartilhados (bancos de dados, APIs de terceiros com rate limit), podem causar gargalos. Nesse caso, mecanismos de limitação (p. ex. Step Functions Map with MaxConcurrency, semáforos, etc.) podem ser necessários.
  * *EKS:* A escalabilidade aqui envolve *fila + consumidores*. A fila SQS pode segurar virtualmente quantas mensagens forem necessárias. Os *consumidores* em EKS podem ser escalados horizontalmente (mais pods) manualmente ou automaticamente. Uma prática comum é usar **KEDA (Kubernetes Event-Driven Autoscaling)** ou Horizontal Pod Autoscaler para aumentar o número de pods baseado no tamanho da fila ou na taxa de mensagens. Isso permite reagir a picos, mas não é tão instantâneo quanto o Lambda. Leva algum tempo para o HPA detectar carga e o cluster iniciar novos pods; se novos pods exigirem novos nós EC2, somam-se minutos para subir instâncias (a não ser que use Fargate). Portanto, a escalabilidade aqui é **mais configurável mas menos automática**. Você tem controle para, por exemplo, nunca passar de X pods (limitando concorrência máxima por design) – útil para proteger sistemas downstream. EKS também permite escalonar recursos verticalmente (dar mais CPU/RAM a pods) se uma tarefa ficar maior, algo que no Lambda também é possível (aumentar memória da função) mas com menos granularidade.

Em termos de *escalabilidade global do processo*, Step Functions Standard suporta por padrão até 2.000 execuções *concomitantes* e pode ser aumentado sob demanda, enquanto Step Functions Express (se fosse usado) suporta taxas muito maiores de throughput mas com outras limitações. Como o foco aqui é Standard (dado o uso de callback de longa duração), assumimos que a orquestração em si não será o gargalo. O desafio é escalar as tasks. Assim, se você precisa de **escala massiva e rápida**, Lambdas se encaixam melhor (com atenção às quotas e orquestração de erros). Se você precisa de **escala controlada ou dependente de eventos acumulados**, EKS com SQS dá flexibilidade – por exemplo, processar 1000 tasks gradualmente conforme capacidade, em vez de de uma vez.

**Resumo:** Lambdas oferecem escalabilidade automática e simplicidade com possível penalidade de cold start e custos lineares por demanda; já a solução com EKS + SQS oferece maior controle sobre *como* escalar (pode impor limites ou padrões), atendendo bem cenários de longa duração ou integração especial, mas à custa de latência e complexidade operacional. Em muitos casos, um **híbrido** é possível: usar Lambdas na maioria das tasks e reservar o padrão callback para pontos específicos do fluxo que realmente precisem.

## Arquitetura de Referência – Step Functions com Lambda

&#x20;*Figura 1: Orquestração com Step Functions invocando funções Lambda de forma síncrona.* Na arquitetura acima, o AWS Step Functions executa um **fluxo de trabalho** composto por múltiplos estados. Os estados do tipo **Task** chamam diretamente funções **AWS Lambda** para realizar o trabalho de cada *Service Task* original do Camunda. Cada chamada é **síncrona**, ou seja, o Step Functions espera a execução completar para receber o resultado (ilustrado pela seta de mão dupla indicando chamada e resposta).

Em termos de componentes:

* O **State Machine** do Step Functions contém a lógica do processo (sequência, condições, paralelismo, retries, etc.). Para cada Service Task que migramos, definimos um estado Task com campo `Resource` apontando para o ARN da função Lambda correspondente. Podemos aproveitar mecanismos do Step Functions como *Retry/Catch* para replicar tratativas de erro que existiam no Camunda (ex: tempos de espera, tentativas).

* As **funções Lambda** implementam efetivamente o que antes eram as ações da Service Task. Por exemplo, se no Camunda havia um delegate Java chamando um serviço REST, agora temos um Lambda (em Node.js, Python, Java, etc.) que faz a mesma chamada HTTP. Cada Lambda é implantado com um IAM Role que lhe dá permissão nos recursos necessários (se aplicável, e.g. gravar no DynamoDB). O Step Functions assume a sua própria role que precisa de permissão para invocar as Lambdas (via AWS IAM).

* A invocação do Lambda pelo Step Functions pode ser feita de duas formas: **síncrona** (padrão) ou **assíncrona**. No caso geral de orquestração, usamos síncrona para obter o resultado imediatamente. A chamada é efetuada através do serviço AWS Lambda e o Step Functions fica aguardando a conclusão. Internamente, há um timeout default (infinito para Standard Workflows, ou limitado se definido no estado ou se a função tiver timeout menor). Se a função demora demais e excede seu próprio timeout ou um timeout configurado no Step Functions, o estado falha. Podemos configurar o campo `TimeoutSeconds` no estado Task para forçar uma falha se passar de X segundos, adicionando resiliência.

* **Próximos passos:** Após o Lambda retornar (com sucesso ou erro), o Step Functions mapeia o resultado para o *output* daquele estado. Em caso de sucesso, esse output pode alimentar o próximo passo (por exemplo, dados transformados). Em caso de erro (ex: exceção no Lambda), o Step Functions pode acionar uma política de retry definida no estado ou cair em um estado de *Catch* para tratamento (por ex., encaminhar para fluxo de compensação ou registrar erro). Isso nos dá um robusto controle de fluxo sem precisar codificar isso manualmente dentro das tasks, algo já disponível no Camunda via bordas de erro, mas facilitado aqui declarativamente.

* Em termos de **monitoramento**, cada execução do Step Functions pode ser acompanhada visualmente no Console AWS, vendo cada estado e seu resultado. As Lambdas em si geram logs no Amazon CloudWatch Logs, e podem gerar métricas customizadas se necessário. O Step Functions também gera métricas (p. ex., quantidade de execuções, tempos) e eventos (Step Execution Started/Succeeded/Failed) que podem ser capturados via EventBridge.

Essa arquitetura **Step Functions + Lambda** é totalmente **serverless**, ou seja, não há servidores gerenciados por você. Escala de acordo com uso: se 100 processos iniciarem simultaneamente, o Step Functions orquestrará todos (cada um invocando suas Lambdas) e o AWS Lambda alocará instâncias conforme necessário para cada invocação. Não há risco de sobrecarregar um servidor aplicativo como no Camunda on-prem, pois a nuvem aloca mais recursos automaticamente (até limites definidos). Isso resulta em alta disponibilidade e paralelismo.

Um cuidado arquitetural: evite colocar lógicas extremamente longas ou bloqueantes dentro das Lambdas. Conforme nossa decisão, tais casos devem migrar para um padrão assíncrono. Lambdas são melhores em **tarefas rápidas**; se abusarmos com tarefas longas, podemos enfrentar timeouts ou custos inesperados. Mas para a grande maioria das Service Tasks comuns, esta arquitetura é simples e eficaz.

## Arquitetura de Referência – Step Functions com SQS + EKS (Callback Pattern)

&#x20;*Figura 2: Orquestração usando Step Functions com envio de mensagem a SQS e processamento assíncrono em um worker no EKS (padrão callback).* Aqui vemos como um Step Functions pode coordenar uma tarefa externa. Os componentes e fluxo são:

1. O **Step Functions** inicia um estado Task configurado para **esperar por callback**. Em vez de ter `Resource` apontando para Lambda, ele usa uma integração do tipo *Send to SQS with Task Token*. Isso significa que o Step Functions gera um **Task Token** único e o inclui numa mensagem enviada a uma fila **Amazon SQS** (note a seta saindo do State Machine para a SQS na figura, "Envia mensagem c/ token"). A mensagem normalmente contém os dados da tarefa e esse token. Imediatamente após enviar, o Step Functions entra em modo de espera *waiting* – ele não prossegue até alguém retornar o token via API (ou até um timeout expirar).

2. A **fila SQS** recebe a mensagem. Ela atua como um *buffer durável*. No lado do EKS, temos um ou mais **workers** rodando (pode ser um Deployment com pods replicados, ou um Job disparado via algum operador – design a critério). Esses pods estão executando um programa de **polling** ou consomem mensagens via long polling da SQS. Assim, logo que a mensagem entra na fila, um dos pods a recebe (seta "Worker consome mensagem" na figura, do SQS para o EKS).

3. O **worker no EKS** processa a mensagem: ele extrai o conteúdo, realiza a lógica necessária (que antes era a Service Task do Camunda). Isso pode envolver chamadas a outros serviços, computação intensa, acesso a recursos locais, etc., conforme o caso de uso. Como ele possui o **Task Token**, quando conclui o trabalho ele prepara a resposta (resultado ou erro). Então, o worker faz uma chamada HTTP para a **API do Step Functions** – mais especificamente ele invoca **SendTaskSuccess** ou **SendTaskFailure** passando o token e o resultado. Essa chamada REST/SDK entrega de volta o controle ao Step Functions. Na figura, isso é representado pela seta pontilhada do EKS de volta para o State Machine, "Callback (com token)". Usamos pontilhado para indicar que é uma chamada *externa assíncrona* em vez de uma transição interna direta.

4. Ao receber o callback, o Step Functions **desbloqueia** o estado que estava em espera. O token casa com a execução em andamento, permitindo ao Step Functions continuar. Se o callback foi de sucesso, o payload enviado se torna o output do estado; se foi de falha, o Step Functions lança a execução para a lógica de erro daquele estado (similar a uma exceção). A partir daí, o fluxo segue para o próximo estado definido na máquina (ou encerra se era o último).

5. A mensagem SQS, uma vez processada com sucesso, é removida da fila (o próprio ato de chamar SendTaskSuccess pode ser parte do processamento final do worker antes de deletar/acknowledge a mensagem, dependendo de implementação). Em caso de falha no processamento no lado EKS, o worker pode optar por não deletar a mensagem – assim ela retornará à fila após o timeout de visibilidade, para ser tentada novamente ou ir para a Dead Letter Queue (se configurada) após um número de tentativas.

Em relação à implementação no EKS: você pode implementar o consumer de SQS de várias formas. Linguagens populares têm SDKs para ler SQS (por exemplo, usando long polling para buscar mensagens). Alternativamente, existem projetos como **KEDA** (Kubernetes Event Driven Autoscaler) que podem acionar escalonamento e execução de pods com base em mensagens em fila. Uma abordagem simples é rodar um Deployment com, digamos, N réplicas, cada um executando um loop que espera mensagens na SQS e processa. Se o volume variar, o HPA/KEDA pode aumentar ou diminuir o número de pods conforme o tamanho da fila. Outra opção arquitetural é usar AWS Lambda como consumidor e repassar a tarefa para EKS, mas isso complicaria sem necessidade se já estamos focando em EKS – normalmente, ou vai para Lambda ou vai para EKS direto. Aqui assumimos que o EKS faz tudo após a fila.

Alguns pontos adicionais nesta arquitetura de callback:

* **Segurança:** O Step Functions coloca o token na mensagem SQS. É importante que somente o componente autorizado (EKS worker) consiga consumir e usar esse token, pois ele concede acesso para liberar a execução. Use as políticas do SQS para restringir quem pode ler a fila. No lado do EKS, o pod deve ter permissões IAM para chamar `SendTaskSuccess` no Step Functions. Recomenda-se uso de IRSA (IAM Role for Service Account) para dar ao pod a credencial AWS necessária de forma granular.

* **Timeouts e Heartbeat:** No Step Functions, ao usar callback, pode-se configurar `TimeoutSeconds` no estado para limitar quanto tempo esperar pelo callback. Se esse tempo estoura sem receber o token, o Step Functions considera falha (Timeout). Opcionalmente, pode-se usar `HeartbeatSeconds` – mas no caso de SQS puro, não há suporte a heartbeat *automático*. Heartbeat é mais usado com integrações como Activity Workers ou alguns SDKs que chamam SendTaskHeartbeat. Em cenários EKS, você poderia, se quisesse, periodicamente chamar `SendTaskHeartbeat` via API do Step Functions para sinalizar "ainda estou vivo processando", mas isso complicaria; geralmente confia-se no timeout e no reprocessamento via fila em caso de algo demorar demais.

* **Entrega Garantida:** Com SQS, temos garantia *pelo menos uma vez* de entrega. O Step Functions só libera o fluxo com *exatamente uma vez* quando recebe o token de volta. Entretanto, se um worker falhar após processar mas antes de enviar o callback, a mensagem pode retornar à fila e ser processada de novo. Assim, a idempotência do processamento é algo a projetar. No Camunda, uma Service Task podia ser marcada como não repetível ou as transações tratavam isso. Aqui, ao desenhar o worker, considere usar algum **ID de deduplicação** ou marcação de tarefas concluídas para não duplicar efeitos colaterais se a mesma mensagem for processada duas vezes acidentalmente. O Step Functions em si não sabe desses detalhes – ele verá dois callbacks talvez, o primeiro que chegar consome o token e o segundo seria rejeitado (token inválido, já usado). A fila SQS FIFO poderia ser usada se ordem e unicidade forem cruciais (junto com MessageGroupID e deduplication ID), mas isso impõe throughput limitado. Em muitos casos, SQS padrão com cuidado no worker já basta.

* **Observabilidade:** Monitorar essa arquitetura requer juntar informações de múltiplos lugares: a execução Step Functions (que te dirá quando o estado foi acionado e quando retomou), a fila SQS (métricas de msgs enfileiradas, taxa de ingressos/consumo) e o Kubernetes (logs dos pods, métricas de CPU/memória, etc.). Ferramentas como CloudWatch podem ser integradas em todas as pontas – por exemplo, o worker pode logar no CloudWatch via Fluent Bit. Também pode-se instrumentar o Step Functions to emitir eventos ao iniciar uma tarefa externa (que poderia acionar um log em algum lugar). Em resumo, dá um pouco mais de trabalho para ter rastreabilidade ponta a ponta comparado ao Lambda (que centraliza logs por request), mas é administrável. Uma dica: incluir no payload da mensagem um identificador de correlação (p. ex., Execution ID do Step Functions, ou business key), e propagá-lo nos logs do pod, facilita correlacionar um processamento específico com a execução do workflow.

Em termos de arquitetura cloud, essa abordagem traz o **Kubernetes como parte da solução**, o que pode aproveitar investimentos existentes (como clusters EKS já em uso na empresa). É uma forma de extender o Step Functions para workloads arbitrários, enquanto ainda se beneficia da coordenação visível e das features de workflow (retries, paralelismo, espera por sinais externos, etc.) que o Step Functions fornece.

## Conclusão

A migração de Service Tasks do Camunda para AWS Step Functions exige avaliar cada caso e escolher a melhor implementação nas opções da AWS. De modo geral, **funções Lambda** atendem a maioria das tarefas de curta duração com simplicidade e baixo acoplamento, proporcionando escalabilidade automática e baixo custo para uso esporádico. Já o uso de **EKS com o padrão de callback via SQS** se justifica para tarefas mais exigentes – seja por duração, por necessidade de ambiente customizado, ou por requisitos de integração – permitindo executar virtualmente qualquer processamento dentro de um fluxo serverless orquestrado.

Em muitos projetos, a solução ótima pode combinar as duas abordagens: alguns estados do workflow chamando Lambdas diretamente, e outros estados (aqueles que antes eram problemáticos no Camunda ou exigiam espera) usando callback para sistemas externos ou pods no EKS. O AWS Step Functions suporta ambos os estilos simultaneamente, então você tem liberdade para desenhar cada parte do processo com a ferramenta mais adequada.

Esperamos que este guia sirva como referência abrangente. Use a **tabela de decisão** para uma visão rápida dos critérios e as seções detalhadas para entender o racional por trás de cada escolha. Lembre-se de testar as abordagens na prática em um ambiente controlado antes da migração definitiva – por exemplo, medir tempos de execução de um Lambda vs container para seu caso de uso, estimar custos com dados reais, e validar se a semântica do processo de negócio permanece correta em ambiente AWS. Com planejamento cuidadoso, a migração pode resultar em processos mais escaláveis, com menor manutenção de infraestrutura, e prontos para tirar proveito do ecossistema serverless da AWS.

**Referências selecionadas:** Este documento foi baseado em melhores práticas de mercado e recomendações da AWS. Por exemplo, para tarefas longas utilizamos o *callback pattern* conforme descrito pela AWS, aproveitando o fato de Step Functions Standard permitir execuções de até 365 dias. A comparação entre Lambda e containers considerou fatores de tempo de execução, custo e controle. Esses princípios guiaram a elaboração de um framework decisório prático para arquitetos e desenvolvedores. Em suma, aproveite a flexibilidade do Step Functions e das opções de computação da AWS para construir uma solução sob medida, mantendo ou melhorando os SLAs que o Camunda oferecia, agora com a elasticidade e o pay-per-use da nuvem. Boa migração!
